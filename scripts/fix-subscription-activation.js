#!/usr/bin/env node

/**
 * Script para corregir problemas de activaci√≥n de suscripciones
 * Aplica todas las mejoras implementadas y corrige suscripciones problem√°ticas
 */

const { createClient } = require('@supabase/supabase-js');
const { MercadoPagoConfig, PreApproval } = require('mercadopago');
const fs = require('fs');
const path = require('path');

// Configuraci√≥n
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

const client = new MercadoPagoConfig({
  accessToken: process.env.MERCADOPAGO_ACCESS_TOKEN,
});
const preApproval = new PreApproval(client);

// Configuraci√≥n del script
const CONFIG = {
  DRY_RUN: process.argv.includes('--dry-run'),
  VERBOSE: process.argv.includes('--verbose'),
  FORCE_EMAIL: process.argv.includes('--force-email'),
  TARGET_REFERENCE: process.argv.find(arg => arg.startsWith('--reference='))?.split('=')[1],
  MAX_RETRIES: 3,
  BATCH_SIZE: 10
};

console.log('üîß Iniciando correcci√≥n de activaci√≥n de suscripciones...');
console.log('Configuraci√≥n:', CONFIG);

/**
 * Funci√≥n principal
 */
async function main() {
  try {
    // 1. Aplicar migraci√≥n de base de datos
    console.log('\nüìä Aplicando migraci√≥n de base de datos...');
    await applyDatabaseMigration();

    // 2. Identificar suscripciones problem√°ticas
    console.log('\nüîç Identificando suscripciones problem√°ticas...');
    const problematicSubscriptions = await findProblematicSubscriptions();
    
    if (problematicSubscriptions.length === 0) {
      console.log('‚úÖ No se encontraron suscripciones problem√°ticas');
      return;
    }

    console.log(`üìã Encontradas ${problematicSubscriptions.length} suscripciones problem√°ticas`);

    // 3. Procesar cada suscripci√≥n
    const results = {
      fixed: 0,
      failed: 0,
      skipped: 0,
      errors: []
    };

    for (const subscription of problematicSubscriptions) {
      try {
        console.log(`\nüîÑ Procesando suscripci√≥n: ${subscription.external_reference}`);
        const result = await processProblematicSubscription(subscription);
        
        if (result.success) {
          results.fixed++;
          console.log(`‚úÖ Suscripci√≥n corregida: ${subscription.id}`);
        } else {
          results.failed++;
          results.errors.push({
            subscription_id: subscription.id,
            error: result.error
          });
          console.log(`‚ùå Error procesando suscripci√≥n: ${result.error}`);
        }
      } catch (error) {
        results.failed++;
        results.errors.push({
          subscription_id: subscription.id,
          error: error.message
        });
        console.error(`üí• Error inesperado:`, error);
      }
    }

    // 4. Generar reporte
    console.log('\nüìä Generando reporte final...');
    await generateReport(results, problematicSubscriptions);

    console.log('\nüéâ Proceso completado');
    console.log(`‚úÖ Corregidas: ${results.fixed}`);
    console.log(`‚ùå Fallidas: ${results.failed}`);
    console.log(`‚è≠Ô∏è Omitidas: ${results.skipped}`);

  } catch (error) {
    console.error('üí• Error cr√≠tico en el proceso:', error);
    process.exit(1);
  }
}

/**
 * Aplica la migraci√≥n de base de datos
 */
async function applyDatabaseMigration() {
  if (CONFIG.DRY_RUN) {
    console.log('üîç [DRY RUN] Simulando aplicaci√≥n de migraci√≥n...');
    return;
  }

  try {
    // Leer archivo de migraci√≥n
    const migrationPath = path.join(__dirname, '..', 'supabase', 'migrations', '20241231_add_unique_constraint.sql');
    
    if (!fs.existsSync(migrationPath)) {
      console.log('‚ö†Ô∏è Archivo de migraci√≥n no encontrado, continuando...');
      return;
    }

    const migrationSQL = fs.readFileSync(migrationPath, 'utf8');
    
    // Ejecutar migraci√≥n (esto normalmente se har√≠a con supabase CLI)
    console.log('üìù Migraci√≥n debe aplicarse manualmente con: supabase db push');
    console.log('üìÅ Archivo: supabase/migrations/20241231_add_unique_constraint.sql');
    
  } catch (error) {
    console.error('‚ùå Error aplicando migraci√≥n:', error);
    throw error;
  }
}

/**
 * Encuentra suscripciones problem√°ticas
 */
async function findProblematicSubscriptions() {
  try {
    let query = supabase
      .from('unified_subscriptions')
      .select('*')
      .in('status', ['pending', 'processing'])
      .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()); // √öltimos 7 d√≠as

    // Si se especifica una referencia espec√≠fica
    if (CONFIG.TARGET_REFERENCE) {
      query = query.eq('external_reference', CONFIG.TARGET_REFERENCE);
    }

    const { data, error } = await query.order('created_at', { ascending: false });

    if (error) {
      throw new Error(`Error consultando suscripciones: ${error.message}`);
    }

    // Filtrar suscripciones que realmente necesitan correcci√≥n
    const problematic = [];
    
    for (const subscription of data || []) {
      const needsFix = await needsActivationFix(subscription);
      if (needsFix) {
        problematic.push(subscription);
      }
    }

    return problematic;
  } catch (error) {
    console.error('Error encontrando suscripciones problem√°ticas:', error);
    throw error;
  }
}

/**
 * Verifica si una suscripci√≥n necesita correcci√≥n
 */
async function needsActivationFix(subscription) {
  try {
    // Verificar estado en MercadoPago
    if (subscription.mercadopago_subscription_id) {
      const mpSubscription = await preApproval.get({
        id: subscription.mercadopago_subscription_id
      });

      // Si est√° aprobada en MP pero pendiente en nuestra DB
      if (['authorized', 'approved', 'active'].includes(mpSubscription.status) && 
          subscription.status === 'pending') {
        return true;
      }
    }

    // Verificar si tiene external_reference problem√°tico
    if (subscription.external_reference === '643f69a22e5542c183f86d5114848662') {
      return true;
    }

    // Verificar si lleva mucho tiempo pendiente
    const createdAt = new Date(subscription.created_at);
    const hoursSinceCreation = (Date.now() - createdAt.getTime()) / (1000 * 60 * 60);
    
    if (hoursSinceCreation > 2 && subscription.status === 'pending') {
      return true;
    }

    return false;
  } catch (error) {
    console.error(`Error verificando suscripci√≥n ${subscription.id}:`, error);
    return false;
  }
}

/**
 * Procesa una suscripci√≥n problem√°tica
 */
async function processProblematicSubscription(subscription) {
  try {
    console.log(`  üìã ID: ${subscription.id}`);
    console.log(`  üìß Usuario: ${subscription.user_email}`);
    console.log(`  üì¶ Producto: ${subscription.product_name}`);
    console.log(`  üîó Referencia: ${subscription.external_reference}`);
    console.log(`  üìä Estado actual: ${subscription.status}`);

    if (CONFIG.DRY_RUN) {
      console.log('  üîç [DRY RUN] Simulando correcci√≥n...');
      return { success: true, action: 'simulated' };
    }

    // 1. Verificar estado en MercadoPago
    let mpStatus = null;
    let mpData = null;

    if (subscription.mercadopago_subscription_id) {
      try {
        const mpSubscription = await preApproval.get({
          id: subscription.mercadopago_subscription_id
        });
        mpStatus = mpSubscription.status;
        mpData = mpSubscription;
        console.log(`  üí≥ Estado en MercadoPago: ${mpStatus}`);
      } catch (mpError) {
        console.log(`  ‚ö†Ô∏è Error consultando MercadoPago: ${mpError.message}`);
      }
    }

    // 2. Activar suscripci√≥n si est√° aprobada
    if (['authorized', 'approved', 'active'].includes(mpStatus) || 
        subscription.external_reference === '643f69a22e5542c183f86d5114848662') {
      
      console.log('  üîÑ Activando suscripci√≥n...');
      
      // Calcular next_billing_date
      const nextBillingDate = new Date();
      nextBillingDate.setDate(nextBillingDate.getDate() + 30);

      const updateData = {
        status: 'active',
        activated_at: new Date().toISOString(),
        next_billing_date: nextBillingDate.toISOString(),
        updated_at: new Date().toISOString()
      };

      if (mpData) {
        updateData.mercadopago_data = mpData;
      }

      const { error: updateError } = await supabase
        .from('unified_subscriptions')
        .update(updateData)
        .eq('id', subscription.id);

      if (updateError) {
        throw new Error(`Error actualizando suscripci√≥n: ${updateError.message}`);
      }

      // 3. Crear registro de facturaci√≥n
      console.log('  üí∞ Creando registro de facturaci√≥n...');
      await createBillingRecord(subscription, mpData);

      // 4. Enviar email de confirmaci√≥n
      if (CONFIG.FORCE_EMAIL || !await hasConfirmationEmailBeenSent(subscription.id)) {
        console.log('  üìß Enviando email de confirmaci√≥n...');
        await sendConfirmationEmail(subscription);
      } else {
        console.log('  üìß Email ya enviado previamente');
      }

      return { success: true, action: 'activated' };
    }

    // 3. Si no se puede activar, marcar para revisi√≥n manual
    console.log('  ‚ö†Ô∏è Requiere revisi√≥n manual');
    
    const { error: noteError } = await supabase
      .from('unified_subscriptions')
      .update({
        notes: (subscription.notes || '') + ` [REVISI√ìN MANUAL REQUERIDA - ${new Date().toISOString()}]`,
        updated_at: new Date().toISOString()
      })
      .eq('id', subscription.id);

    if (noteError) {
      console.error('Error agregando nota:', noteError);
    }

    return { success: true, action: 'marked_for_review' };

  } catch (error) {
    console.error(`Error procesando suscripci√≥n ${subscription.id}:`, error);
    return { success: false, error: error.message };
  }
}

/**
 * Crea registro de facturaci√≥n
 */
async function createBillingRecord(subscription, mpData) {
  try {
    const billingData = {
      subscription_id: subscription.id,
      user_id: subscription.user_id,
      amount: subscription.amount || 0,
      currency: subscription.currency || 'MXN',
      status: 'paid',
      payment_date: new Date().toISOString(),
      billing_period_start: new Date().toISOString(),
      billing_period_end: subscription.next_billing_date,
      mercadopago_payment_id: mpData?.id,
      created_at: new Date().toISOString()
    };

    const { error } = await supabase
      .from('billing_history')
      .insert(billingData);

    if (error && !error.message.includes('duplicate')) {
      console.error('Error creando registro de facturaci√≥n:', error);
    }
  } catch (error) {
    console.error('Error en createBillingRecord:', error);
  }
}

/**
 * Verifica si ya se envi√≥ email de confirmaci√≥n
 */
async function hasConfirmationEmailBeenSent(subscriptionId) {
  try {
    const { data, error } = await supabase
      .from('email_logs')
      .select('id')
      .eq('subscription_id', subscriptionId)
      .eq('email_type', 'subscription_confirmation')
      .eq('status', 'sent')
      .limit(1);

    return !error && data && data.length > 0;
  } catch (error) {
    console.error('Error verificando email enviado:', error);
    return false;
  }
}

/**
 * Env√≠a email de confirmaci√≥n
 */
async function sendConfirmationEmail(subscription) {
  try {
    // Importar y usar el servicio de email mejorado
    const { enhancedEmailService } = require('../lib/email-service-enhanced');
    
    const emailData = {
      userEmail: subscription.user_email,
      userName: subscription.user_name,
      subscriptionId: subscription.id,
      productName: subscription.product_name,
      planType: subscription.plan_type || 'monthly',
      amount: subscription.amount,
      currency: subscription.currency || 'MXN',
      nextBillingDate: subscription.next_billing_date,
      status: 'active'
    };

    const result = await enhancedEmailService.sendSubscriptionConfirmationEmail(emailData);
    
    if (!result.success) {
      console.error('Error enviando email:', result.error);
    }

    return result.success;
  } catch (error) {
    console.error('Error en sendConfirmationEmail:', error);
    return false;
  }
}

/**
 * Genera reporte final
 */
async function generateReport(results, subscriptions) {
  const report = {
    timestamp: new Date().toISOString(),
    config: CONFIG,
    summary: results,
    processed_subscriptions: subscriptions.length,
    details: results.errors
  };

  const reportPath = path.join(__dirname, '..', 'reports', `subscription-fix-${Date.now()}.json`);
  
  // Crear directorio si no existe
  const reportsDir = path.dirname(reportPath);
  if (!fs.existsSync(reportsDir)) {
    fs.mkdirSync(reportsDir, { recursive: true });
  }

  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  console.log(`üìä Reporte guardado en: ${reportPath}`);
}

// Ejecutar script
if (require.main === module) {
  main().catch(error => {
    console.error('üí• Error fatal:', error);
    process.exit(1);
  });
}

module.exports = {
  main,
  findProblematicSubscriptions,
  processProblematicSubscription
};